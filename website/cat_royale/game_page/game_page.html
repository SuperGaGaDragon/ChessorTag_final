<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cat Royale - Game Page</title>
    <script>
        // Global defaults so other scripts can read side/host safely.
        window.GAME_SIDE = window.GAME_SIDE || 'spectate';
        window.IS_HOST = window.GAME_SIDE === 'a';
        window.isHost = window.IS_HOST;
        window.MY_SIDE = window.GAME_SIDE;
    </script>
    <script src="elixir.js"></script>
    <script src="../moving/general.js"></script>
    <script src="../moving/pieces_HP/aggressive_tower_hp.js"></script>
    <script src="../moving/pieces_HP/solid_tower_hp.js"></script>
    <script src="../moving/pieces_HP/shouter_hp.js"></script>
    <script src="../moving/pieces_HP/fighter_hp.js"></script>
    <script src="../moving/pieces_HP/ruler_hp.js"></script>
    <script src="../moving/pieces_HP/squirmer_hp.js"></script>
    <script src="../moving/pieces_HP/king_tower_hp.js"></script>
    <script src="../moving/piece_attack/shouter_attack.js"></script>
    <script src="../moving/piece_attack/squirmer_attack.js"></script>
    <script src="../moving/piece_attack/ruler_attack.js"></script>
    <script src="../moving/piece_attack/aggressive_tower_attack.js"></script>
    <script src="../moving/piece_attack/solid_tower_attack.js"></script>
    <script src="../moving/pieces_move/shouter_move.js"></script>
    <script src="../moving/pieces_move/squirmer_move.js"></script>
    <script src="../moving/pieces_move/fighter_move.js"></script>
    <script src="../moving/pieces_move/ruler_move.js"></script>
    <script src="../moving/pieces_move/aggressive_tower_move.js"></script>
    <script src="../moving/pieces_move/solid_tower_move.js"></script>
    <script src="../piece_deploy/piece_deploy.js"></script>
    <script src="../pieces_ability/aggressive_tower_ability.js"></script>
    <script src="../pieces_ability/solid_tower_ability.js"></script>
    <script src="../pieces_ability/ruler_ability.js"></script>
    <script src="game_ends.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', 'Helvetica', sans-serif;
            background: #E8EAED;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 15px;
        }

        .game-container {
            width: 1000px;
            height: 700px;
            background-color: #D9DDE3;
            border: 6px solid #000000;
            border-radius: 15px;
            padding: 18px;
            display: grid;
            grid-template-columns: 90px 60px 1fr 140px;
            grid-template-rows: 55px 1fr 110px;
            gap: 10px;
            position: relative;
        }


        /* 左侧区域 */
        .left-section {
            grid-row: 1 / 4;
            grid-column: 1;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .elixer-count {
            background-color: #F0E8E0;
            border: 3px solid #2F5233;
            border-radius: 10px;
            padding: 10px;
            text-align: center;
            font-size: 13px;
            font-weight: bold;
            color: #2F5233;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .emoji-section {
            flex: 1;
            background-color: #E8D4CC;
            border: 3px solid #2F5233;
            border-radius: 10px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            gap: 8px;
        }

        .emoji-section h3 {
            font-size: 13px;
            color: #2F5233;
            margin-bottom: 5px;
        }

        /* Elixir bar 单独分离 */
        .elixer-bar-section {
            grid-row: 1 / 4;
            grid-column: 2;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .elixer-bar {
            background-color: #F5EDD5;
            border: 3px solid #2F5233;
            border-radius: 8px;
            width: 100%;
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .elixer-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(180deg, #F0E4B8 0%, #E8D9A5 100%);
            height: 70%;
            transition: height 0.3s ease;
        }

        .elixer-segments {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            pointer-events: none;
        }

        .elixer-segment {
            flex: 1;
            border-bottom: 2px solid #2F5233;
        }

        .elixer-segment:last-child {
            border-bottom: none;
        }

        /* 中间区域 */
        .center-section {
            grid-column: 3;
            grid-row: 1 / 4;
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow: visible;
        }

        .time-countdown {
            background-color: #E8F0E8;
            border: 3px solid #2F5233;
            border-radius: 10px;
            padding: 10px;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            color: #DD2222;
            height: 55px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: visible;
            position: relative;
        }

        .time-countdown span {
            font-size: 42px;
            font-weight: 900;
            position: relative;
            z-index: 10;
            text-shadow:
                -2px -2px 0 #8B0000,
                -2px -1px 0 #8B0000,
                -2px 0 0 #8B0000,
                -2px 1px 0 #8B0000,
                -2px 2px 0 #8B0000,
                -1px -2px 0 #8B0000,
                -1px 2px 0 #8B0000;
        }

        .game-board {
            background-color: #F5EDD5;
            border: 3px solid #2F5233;
            border-radius: 10px;
            padding: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .board-grid {
            width: 100%;
            max-width: 520px;
            aspect-ratio: 1;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 3px;
        }

        .board-cell {
            background-color: #F8F0DC;
            border: 2px solid #2F5233;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            aspect-ratio: 1;
            position: relative;
            z-index: 1;
        }

        .cell-label {
            position: absolute;
            left: 4px;
            bottom: 2px;
            font-size: 10px;
            font-weight: bold;
            color: rgba(47, 82, 51, 0.55);
            pointer-events: none;
            user-select: none;
        }

        .invalid-flash {
            background-color: #999999 !important;
            transition: none;
        }

        .path-highlight {
            outline: none;
            box-shadow: none;
        }

        .board-cell:hover {
            background-color: #F0E4C0;
            transform: scale(1.05);
        }

        .board-grid {
            position: relative;
        }

        .king-tower {
            display: none; /* Legacy hidden */
        }

        .king-anchor {
            position: relative;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9; /* ensure king towers render above cells */
        }

        .king-anchor img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            pointer-events: none;
        }

        .cards-section {
            background-color: #E8D5E0;
            border: 6px solid #000000;
            border-radius: 10px;
            padding: 12px;
            height: 110px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .card-slot {
            width: 70px;
            height: 85px;
            background-color: #F5E8F0;
            border: 3px solid #2F5233;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            color: #2F5233;
            position: relative;
            overflow: hidden;
        }

        .card-slot:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(47, 82, 51, 0.2);
        }

        /* Deployed piece styling */
        .deployed-piece {
            animation: deployFadeIn 0.3s ease-out;
        }

        @keyframes deployFadeIn {
            from {
                opacity: 0;
                transform: scale(0.5);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* 右侧区域 */
        .right-section {
            grid-row: 1 / 4;
            grid-column: 4;
        }

        .abilities-section {
            background-color: #D5E0E8;
            border: 3px solid #2F5233;
            border-radius: 10px;
            padding: 12px;
            height: 100%;
            display: flex;
            flex-direction: column;
            gap: 12px;
            position: relative;
        }

        .abilities-section::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 40%;
            height: 100%;
            background: linear-gradient(to left, rgba(80, 120, 160, 0.3), transparent);
            border-radius: 0 10px 10px 0;
            pointer-events: none;
        }

        .abilities-section h3 {
            text-align: center;
            font-size: 24px;
            color: #FFFFFF;
            margin-bottom: 5px;
            position: relative;
            z-index: 1;
            font-weight: bold;
            text-shadow:
                -2px -2px 0 #000000,
                2px -2px 0 #000000,
                -2px 2px 0 #000000,
                2px 2px 0 #000000,
                -2px 0 0 #000000,
                2px 0 0 #000000,
                0 -2px 0 #000000,
                0 2px 0 #000000;
        }

        .abilities-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            align-items: center;
            gap: 10px;
            position: relative;
            z-index: 1;
        }

        .ability-button {
            width: 70px;
            height: 70px;
            background-color: #FFFFFF; /* White base */
            border: 6px solid #000000;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease; /* Keep motion smooth, color snaps */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #FFFFFF;
            font-weight: bold;
            overflow: hidden;
            position: relative;
            box-shadow: inset -2px -2px 4px rgba(0, 0, 0, 0.2);
        }

        .ability-button::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.6) 0%, rgba(255, 255, 255, 0.3) 25%, transparent 50%);
            border-radius: 50%;
            pointer-events: none;
            z-index: 2;
        }

        .ability-button img {
            width: 90%;
            height: 90%;
            object-fit: cover;
            position: relative;
            z-index: 1;
            border-radius: 50%;
        }

        .ability-button:nth-child(3) img {
            transform: translateY(8%);
        }

        .ability-button:hover {
            background-color: #FFFFFF; /* Stay white on hover */
            transform: scale(1.1);
            box-shadow: 0 5px 15px rgba(47, 82, 51, 0.25);
        }

        .ability-button:active {
            transform: scale(0.95);
        }

        .ability-button.disabled {
            filter: grayscale(1);
            opacity: 0.55;
            cursor: not-allowed;
            pointer-events: none;
        }

        /* Game Start Dialog */
        .game-start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .game-start-dialog {
            background-color: #FFF9E6;
            border: 6px solid #000000;
            border-radius: 15px;
            padding: 30px;
            display: flex;
            gap: 25px;
            align-items: center;
            max-width: 700px;
        }

        .dialog-cat-image {
            width: 150px;
            height: 150px;
            flex-shrink: 0;
        }

        .dialog-cat-image img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .dialog-content {
            flex: 1;
        }

        .dialog-message {
            font-size: 20px;
            font-weight: bold;
            color: #2F5233;
            margin-bottom: 20px;
            text-align: center;
        }

        .tower-selection {
            display: flex;
            gap: 20px;
            justify-content: center;
        }

        .tower-option {
            width: 120px;
            height: 120px;
            background-color: #FFFFFF;
            border: 4px solid #2F5233;
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            position: relative;
        }

        .tower-option:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .tower-option.selected {
            border-color: #8B5CF6;
            border-width: 6px;
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.5);
        }

        .tower-option img {
            width: 90%;
            height: 90%;
            object-fit: contain;
        }

        .hidden {
            display: none;
        }

        /* Tower Pieces on Board */
        .tower-piece {
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: 8;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 3px solid #5C4033;
            border-radius: 5px;
            background-color: #FFF5F8;
        }

        .tower-piece img {
            width: 110%;
            height: 110%;
            object-fit: contain;
        }

        /* Shouter attack shake */
        @keyframes shouterShake {
            0% { transform: translateX(-3px); }
            100% { transform: translateX(3px); }
        }

        .shouter-attack-shake {
            animation: shouterShake 0.15s ease-in-out infinite alternate;
        }

        /* Aggressive tower specific sizing */
        .tower-piece[data-tower-type="aggressive"] img {
            width: 150%;
            height: 150%;
            object-fit: contain;
        }
    </style>
</head>
<body>
    <!-- Game Start Dialog Overlay -->
    <div class="game-start-overlay" id="game-start-overlay">
        <div class="game-start-dialog">
            <div class="dialog-cat-image">
                <img src="../other_photos/start.png" alt="Cat">
            </div>
            <div class="dialog-content">
                <div class="dialog-message">
                    Choose your tower<br>(double click to confirm, then Ready)
                </div>
                <div class="tower-selection">
                    <div class="tower-option" id="solid-tower-option" data-tower="solid">
                        <img src="../pieces/solid_tower/solid_tower.png" alt="Solid Tower">
                    </div>
                    <div class="tower-option" id="aggressive-tower-option" data-tower="aggressive">
                        <img src="../pieces/agressive_tower/aggressive_tower.png" alt="Aggressive Tower">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="game-container">
        <!-- 左侧区域 - Emoji 和 Elixer Count -->
        <div class="left-section">
            <div class="elixer-count">
                <span>Elixer: <span id="elixer-value">0</span></span>
            </div>
            <div class="emoji-section">
                <h3>Emoji</h3>
            </div>
        </div>

        <!-- Elixir Bar 单独列 -->
        <div class="elixer-bar-section">
            <div class="elixer-bar">
                <div class="elixer-fill"></div>
                <div class="elixer-segments">
                    <div class="elixer-segment"></div>
                    <div class="elixer-segment"></div>
                    <div class="elixer-segment"></div>
                    <div class="elixer-segment"></div>
                    <div class="elixer-segment"></div>
                    <div class="elixer-segment"></div>
                    <div class="elixer-segment"></div>
                    <div class="elixer-segment"></div>
                    <div class="elixer-segment"></div>
                    <div class="elixer-segment"></div>
                </div>
            </div>
        </div>

        <!-- 中间区域 -->
        <div class="center-section">
            <div class="time-countdown">
                <span>Time - <span id="time-value">01:30</span></span>
            </div>

            <div class="game-board">
                <div class="board-grid">
                    <!-- Cells will be injected dynamically to guarantee 8x8 with chess coordinates -->
                </div>
            </div>

            <div class="cards-section">
                <div class="card-slot">Card 1</div>
                <div class="card-slot">Card 2</div>
                <div class="card-slot">Card 3</div>
                <div class="card-slot">Card 4</div>
            </div>
        </div>

        <!-- 右侧区域 -->
        <div class="right-section">
            <div class="abilities-section">
                <h3>Abilities</h3>
                <div class="abilities-container">
                    <div class="ability-button">
                        <img src="../pieces/shouter/shouter.png" alt="Shouter">
                    </div>
                    <div class="ability-button">
                        <img src="../pieces/fighter/fighter.png" alt="Fighter">
                    </div>
                    <div class="ability-button">
                        <img src="../pieces/ruler/ruler.png" alt="Ruler">
                    </div>
                    <div class="ability-button">
                        <img src="../pieces/ruler/ruler.png" alt="Ruler">
                    </div>
                    <div class="ability-button" id="tower-toggle">
                        <img src="../pieces/solid_tower/solid_tower.png" alt="Solid Tower" class="tower-img-1">
                        <img src="../pieces/agressive_tower/aggressive_tower.png" alt="Aggressive Tower" class="tower-img-2" style="display: none;">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let selectedTower = null;
        let playerTowerType = null;
        let opponentTowerType = 'aggressive';
        let currentPlayerTowers = [];
        let timerInterval = null;
        let remainingSeconds = 90;
        let battleStarted = false;
        window.PLAYER_SIDE = window.PLAYER_SIDE || null;
        let OPPONENT_SIDE = null;
        let IS_SPECTATOR = false;
        let boardOrientation = 'a';
        let mySide = window.GAME_SIDE || 'spectate';
        let isHost = window.IS_HOST || false;
        const hasParentBridge = window.parent && window.parent !== window;
        let directBridgeHandler = null;
        let directWs = null;
        let directGameId = null;

        function getTowerTypeForSide(side) {
            const normalized = side === 'b' ? 'b' : 'a';
            return normalized === mySide ? playerTowerType : opponentTowerType;
        }

        function setTowerTypeForSide(side, newType) {
            const normalized = side === 'b' ? 'b' : 'a';
            if (normalized === mySide) {
                playerTowerType = newType;
            } else {
                opponentTowerType = newType;
            }
        }

        if (typeof elixirManager !== 'undefined') {
            elixirManager.onChange = (side, value) => {
                if (window.IS_HOST === true) {
                    postToParent('state_update', {
                        type: 'state_update',
                        event: 'elixir',
                        side,
                        elixir: value
                    });
                }
            };
        }

        function postToParent(type, payload = {}) {
            console.log('[game_page] postToParent called', { type, hasParentBridge, payload });
            if (hasParentBridge) {
                console.log('[game_page] sending postMessage to parent');
                window.parent.postMessage({ type, payload }, '*');
            } else if (typeof directBridgeHandler === 'function') {
                console.log('[game_page] using directBridgeHandler');
                directBridgeHandler(type, payload);
            } else {
                console.warn('[game_page] no parent bridge and no directBridgeHandler!');
            }
        }

        // Make postToParent available globally for piece_deploy.js
        window.postToParent = postToParent;

            function serializePiece(entry) {
                if (!entry) return null;
                return {
                    id: entry.id,
                    owner: entry.allegiance,
                    kind: entry.type,
                    row: entry.position?.row,
                    col: entry.position?.col,
                    hp: entry.hp,
                    max_hp: entry.maxHP,
                    boardImagePath: entry.boardImagePath || null,
                    board_image_path: entry.boardImagePath || null,
                    damage_reduction: entry.damageReduction
                };
            }

        document.addEventListener('DOMContentLoaded', function() {
            const overlay = document.getElementById('game-start-overlay');
            const solidTowerOption = document.getElementById('solid-tower-option');
            const aggressiveTowerOption = document.getElementById('aggressive-tower-option');
            const towerToggle = document.getElementById('tower-toggle');
            const FILES = ['a','b','c','d','e','f','g','h'];
            const CARD_CONFIG = [
                { type: 'shouter', cost: 3, card: '../pieces/shouter/shouter.png', board: '../pieces/shouter/shouter_board.png' },
                { type: 'squirmer', cost: 4, card: '../pieces/squirmer/squirmer.png', board: '../pieces/squirmer/squirmer_board.png' },
                { type: 'fighter', cost: 3, card: '../pieces/fighter/fighter.png', board: '../pieces/fighter/fighter.png' },
                { type: 'ruler', cost: 5, card: '../pieces/ruler/ruler.png', board: '../pieces/ruler/ruler.png' },
            ];
            const cardAssetMap = CARD_CONFIG.reduce((map, card) => {
                map[card.type] = card;
                return map;
            }, {});
            const isProdHost = window.location.hostname === 'chessortag.org' || window.location.hostname === 'www.chessortag.org';
            const apiBase = isProdHost ? 'https://api.chessortag.org' : '';
            let pendingTowerEvents = [];
            let pendingDamageEvents = [];

            function startTowerVisualAttack(attacker, target, towerType) {
                console.log('[startTowerVisualAttack]', towerType, 'attacker:', attacker?.id, 'target:', target?.id, 'visualOnly: true');
                if (!attacker || !target) {
                    console.warn('[startTowerVisualAttack] Missing attacker or target');
                    return;
                }
                if (towerType === 'aggressive_tower' && window.startAggressiveTowerAttack) {
                    window.startAggressiveTowerAttack(attacker, target, true);
                } else if (towerType === 'solid_tower' && window.startSolidTowerAttack) {
                    window.startSolidTowerAttack(attacker, target, true);
                }
            }

            function processPendingTowerEvents() {
                const MAX_AGE_MS = 10000; // Increased from 5000 to 10000 for better spawn delay tolerance
                const now = Date.now();
                pendingTowerEvents = pendingTowerEvents.filter(evt => {
                    const attacker = getPieceEntryById(evt.attacker_id, { warn: false });
                    if (!attacker) {
                        if (now - evt.createdAt < MAX_AGE_MS) return true;
                        console.warn('[tower_attack][pending] drop, attacker missing:', evt.attacker_id);
                        return false;
                    }
                    if (evt.type === 'start') {
                        const target = getPieceEntryById(evt.target_id, { warn: false });
                        if (!target) {
                            if (now - evt.createdAt < MAX_AGE_MS) return true;
                            console.warn('[tower_attack][pending] drop, target missing:', evt.target_id);
                            return false;
                        }
                        startTowerVisualAttack(attacker, target, evt.tower_type || attacker.type);
                    } else if (evt.type === 'stop') {
                        if (pieceDeployment?.stopTowerAttack) {
                            pieceDeployment.stopTowerAttack(attacker);
                        }
                    }
                    return false; // processed
                });
            }

            // 周期性尝试播放在 spawn 前到达的塔攻击事件，避免动画丢失
            setInterval(() => {
                processPendingTowerEvents();
                processPendingDamageEvents();
            }, 400);

            function processPendingDamageEvents() {
                const MAX_AGE_MS = 10000; // Increased from 6000 to 10000 for better spawn delay tolerance
                const now = Date.now();
                pendingDamageEvents = pendingDamageEvents.filter(evt => {
                    const entry = getPieceEntryById(evt.piece_id, { warn: false });
                    if (!entry) {
                        if (now - evt.createdAt < MAX_AGE_MS) return true;
                        console.warn('[damage][pending] drop, piece missing:', evt.piece_id);
                        return false;
                    }
                    applyDamageFromServer(evt.piece_id, evt.hp, evt.attacker_id);
                    return false;
                });
            }

            function buildWsUrl(gameId) {
                if (isProdHost) {
                    return `wss://api.chessortag.org/ws/battle/${gameId}`;
                }
                const proto = window.location.protocol === 'https:' ? 'wss' : 'ws';
                return `${proto}://${window.location.host}/ws/battle/${gameId}`;
            }

            function sendViaDirectWs(msg) {
                if (directWs && directWs.readyState === WebSocket.OPEN) {
                    directWs.send(JSON.stringify(msg));
                } else {
                    console.warn('[battle] WS not open, dropped', msg);
                }
            }

            function setupDirectBridge(gameId) {
                directGameId = gameId;
                directBridgeHandler = (type, payload = {}) => {
                    switch (type) {
                        case 'deploy_request':
                        case 'local_deploy':
                            sendViaDirectWs({
                                type: 'deploy_request',
                                game_id: directGameId,
                                ...payload,
                            });
                            break;
                        case 'local_ruler_move':
                            sendViaDirectWs({
                                type: 'ruler_move_request',
                                game_id: directGameId,
                                ...payload,
                            });
                            break;
                        case 'state_update':
                            sendViaDirectWs({
                                type: 'state_update',
                                game_id: directGameId,
                                ...payload,
                            });
                            break;
                        default:
                            break;
                    }
                };
            }

            async function directJoin(gameId) {
                try {
                    const res = await fetch(`${apiBase}/api/battle/join`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ game_id: gameId }),
                    });
                    if (!res.ok) throw new Error(`Join failed (${res.status})`);
                    const data = await res.json();
                    if (data.side) {
                        updateSideFlags(data.side);
                    }
                } catch (err) {
                    console.error('Join failed:', err);
                }
            }

            let wsReconnectAttempts = 0;
            let wsReconnectTimer = null;
            let wsHeartbeatTimer = null;
            const WS_MAX_RECONNECT_ATTEMPTS = 5;
            const WS_RECONNECT_DELAY = 3000; // 3 seconds
            const WS_HEARTBEAT_INTERVAL = 30000; // 30 seconds

            function startHeartbeat() {
                if (wsHeartbeatTimer) clearInterval(wsHeartbeatTimer);
                wsHeartbeatTimer = setInterval(() => {
                    if (directWs && directWs.readyState === WebSocket.OPEN) {
                        console.log('[battle] Sending heartbeat ping');
                        directWs.send(JSON.stringify({ type: 'ping' }));
                    }
                }, WS_HEARTBEAT_INTERVAL);
            }

            function stopHeartbeat() {
                if (wsHeartbeatTimer) {
                    clearInterval(wsHeartbeatTimer);
                    wsHeartbeatTimer = null;
                }
            }

            function connectDirectWs(gameId) {
                const url = buildWsUrl(gameId);
                console.log('[battle] connecting WS:', url, 'attempt:', wsReconnectAttempts + 1);
                directWs = new WebSocket(url);
                window.battleSocket = directWs;

                directWs.onopen = () => {
                    console.log('[battle] WS open');
                    wsReconnectAttempts = 0; // Reset on successful connection
                    startHeartbeat();
                };

                directWs.onclose = (ev) => {
                    console.log('[battle] WS closed', ev.code, ev.reason);
                    stopHeartbeat();

                    // Handle abnormal closures (code 1006)
                    if (ev.code === 1006) {
                        console.warn('[battle] Abnormal closure detected (1006)');
                        if (wsReconnectAttempts < WS_MAX_RECONNECT_ATTEMPTS) {
                            wsReconnectAttempts++;
                            console.log(`[battle] Attempting reconnect ${wsReconnectAttempts}/${WS_MAX_RECONNECT_ATTEMPTS} in ${WS_RECONNECT_DELAY}ms`);
                            wsReconnectTimer = setTimeout(() => {
                                connectDirectWs(gameId);
                            }, WS_RECONNECT_DELAY);
                        } else {
                            console.error('[battle] Max reconnect attempts reached. Please refresh the page.');
                            alert('Connection lost. Please refresh the page to reconnect.');
                        }
                    } else if (ev.code !== 1000) { // 1000 = normal closure
                        console.warn('[battle] Unexpected closure code:', ev.code);
                    }
                };

                directWs.onerror = (err) => {
                    console.error('[battle] WS error', err);
                    console.log('[battle] readyState:', directWs?.readyState);
                };

                directWs.onmessage = (event) => {
                    console.log('[battle] WS message', event.data);
                    try {
                        const msg = JSON.parse(event.data);
                        switch (msg.type) {
                            case 'pong': // Response to ping
                                console.log('[battle] Received heartbeat pong');
                                break;
                            case 'side':
                                updateSideFlags(msg.side);
                                break;
                            case 'deploy_request':
                                handleDeployRequest(msg);
                                break;
                            case 'state_update':
                                handleStateUpdate(msg);
                                break;
                            case 'start':
                                beginMatch(msg);
                                break;
                            case 'deploy':
                                handleRemoteDeploy(msg);
                                break;
                            case 'ruler_move':
                                handleRemoteRulerMove(msg);
                                break;
                            case 'ruler_move_request':
                                handleRulerMoveRequest(msg);
                                break;
                            case 'opponent_disconnected':
                                alert('Opponent disconnected.');
                                break;
                            default:
                                break;
                        }
                    } catch (err) {
                        console.error('Failed to parse WS message', err);
                    }
                };
            }

            async function initStandaloneNetworking() {
                const params = new URLSearchParams(window.location.search);
                const game = params.get('game');
                if (!game) {
                    console.warn('No game id in URL; networking disabled.');
                    return;
                }
                const gameId = game.trim().toUpperCase();
                setupDirectBridge(gameId);
                await directJoin(gameId);
                connectDirectWs(gameId);
            }

            function sendReadyDirect(towerType) {
                const tower = towerType || playerTowerType || 'solid';
                sendViaDirectWs({ type: 'ready', tower, game_id: directGameId });
            }

            let clickCount = 0;
            let clickTimer = null;

            function spawnPieceFromServer(pieceMsg = {}) {
                if (!pieceMsg) return;
                const row = parseInt(pieceMsg.row ?? pieceMsg.r);
                const col = parseInt(pieceMsg.col ?? pieceMsg.c);
                if (Number.isNaN(row) || Number.isNaN(col)) return;
                const type = pieceMsg.kind || pieceMsg.pieceType;
                const allegiance = pieceMsg.owner || pieceMsg.allegiance || 'a';

                // king_tower 由 registerKingTowers 管理，不在客户端按单格重建
                if (type === 'king_tower') {
                    ensureKingTowers();
                    if (typeof pieceMsg.hp === 'number') {
                        pieceDeployment.updateKingHealth(allegiance, pieceMsg.hp);
                    }
                    return;
                }

                // Check if piece already exists (prevent duplicate spawns)
                if (pieceMsg.id) {
                    const existing = pieceDeployment.boardPieces.find(p => p.id === pieceMsg.id);
                    if (existing) {
                        console.log(`[spawnPieceFromServer] Piece ${pieceMsg.id} already exists, skipping spawn`);
                        return;
                    }
                }

                const cell = document.querySelector(`.board-cell[data-row="${row}"][data-col="${col}"]`);
                if (!cell) return;
                const pieceEntry = pieceDeployment.deployPiece(cell, null, {
                    fromNetwork: true,
                    skipElixir: true,
                    pieceType: type,
                    allegiance,
                    id: pieceMsg.id,
                    cost: pieceMsg.cost,
                    boardImagePath: pieceMsg.boardImagePath
                });
                if (pieceEntry) {
                    ensureHealthBarAttached(pieceEntry);
                    if (typeof pieceMsg.hp === 'number') pieceEntry.hp = pieceMsg.hp;
                    if (typeof pieceMsg.max_hp === 'number') pieceEntry.maxHP = pieceMsg.max_hp;
                    if (pieceEntry.healthBar && typeof pieceEntry.healthBar.update === 'function' && typeof pieceEntry.hp === 'number') {
                        pieceEntry.healthBar.update(pieceEntry.hp);
                    }
                    processPendingTowerEvents();
                    processPendingDamageEvents();
                    ensureKingTowers();
                }
            }

            function applyDamageFromServer(pieceId, hp, attackerId = null) {
                const entry = getPieceEntryById(pieceId, { warn: false });
                if (!entry) {
                    console.warn('[applyDamageFromServer] Piece not found, queuing:', pieceId, 'hp:', hp);
                    pendingDamageEvents.push({
                        piece_id: pieceId,
                        hp,
                        attacker_id: attackerId,
                        createdAt: Date.now()
                    });
                    return;
                }

                console.log('[applyDamageFromServer]', entry.type, entry.id, 'hp:', entry.hp, '->', hp, 'hasHealthBar:', !!entry.healthBar);

                // Ensure healthBar exists
                ensureHealthBarAttached(entry);
                if (!entry.healthBar && typeof pieceDeployment?.attachHealthBar === 'function') {
                    console.log('[applyDamageFromServer] Manually attaching healthBar for:', entry.id);
                    pieceDeployment.attachHealthBar(entry);
                }

                // Check again after attachment attempts
                if (!entry.healthBar) {
                    console.warn('[applyDamageFromServer] Failed to create healthBar for:', entry.type, entry.id, 'element:', !!entry.element);
                }

                // Force sync HP regardless of local calculation
                const oldHP = entry.hp;
                entry.hp = hp;

                // Update healthBar
                if (entry.healthBar && typeof entry.healthBar.update === 'function') {
                    entry.healthBar.update(entry.hp);
                    console.log('[applyDamageFromServer] Updated healthBar:', oldHP, '->', entry.hp);
                } else {
                    console.warn('[applyDamageFromServer] Cannot update healthBar - healthBar:', !!entry.healthBar, 'update:', typeof entry.healthBar?.update);
                }

                if (typeof pieceDeployment.refreshHealthTooltip === 'function') {
                    pieceDeployment.refreshHealthTooltip(entry);
                }

                // If HP <= 0, trigger death
                if (hp <= 0 && !entry._isDead) {
                    pieceDeployment.handleDeath(entry);
                }
                // Fallback: 在 CLIENT 端补播攻击动画，避免攻击事件丢失后无视觉
                if (!isHost && entry && attackerId) {
                    const attacker = getPieceEntryById(attackerId, { warn: false });
                    if (!attacker) {
                        console.warn('[damage fallback] attacker missing for id:', attackerId);
                    } else {
                        // 播放对应类型的攻击特效
                        if (attacker.type === 'solid_tower' || attacker.type === 'aggressive_tower') {
                            startTowerVisualAttack(attacker, entry, attacker.type);
                        } else if (attacker.type === 'shouter' && window.startShouterAttack) {
                            console.log('[CLIENT] Starting shouter visual attack:', attacker.id, '->', entry.id);
                            window.startShouterAttack(attacker, entry, true);
                        } else if (attacker.type === 'fighter' && window.startFighterAttack) {
                            console.log('[CLIENT] Starting fighter visual attack:', attacker.id, '->', entry.id);
                            window.startFighterAttack(attacker, entry, true);
                        } else if (attacker.type === 'ruler' && window.startRulerAttack) {
                            console.log('[CLIENT] Starting ruler visual attack:', attacker.id, '->', entry.id);
                            window.startRulerAttack(attacker, entry, true);
                        } else if (attacker.type === 'squirmer' && window.startSquirmerAttack) {
                            console.log('[CLIENT] Starting squirmer visual attack:', attacker.id, '->', entry.id);
                            window.startSquirmerAttack(attacker, entry, true);
                        }
                    }
                }
            }

            function handleDeathFromServer(pieceId) {
                const entry = pieceDeployment.boardPieces.find(p => p.id === pieceId);
                if (!entry) {
                    console.warn('[death] Piece not found:', pieceId);
                    return;
                }
                // For solid/aggressive towers, force visual update even if already marked dead
                if ((entry.type === 'solid_tower' || entry.type === 'aggressive_tower') && entry._isDead) {
                    // Force visual death effect for towers
                    if (entry.type === 'solid_tower' && typeof window.handleSolidTowerDeath === 'function') {
                        window.handleSolidTowerDeath(entry);
                    } else if (entry.type === 'aggressive_tower' && typeof window.handleAggressiveTowerDeath === 'function') {
                        window.handleAggressiveTowerDeath(entry);
                    }
                    return;
                }
                // Prevent duplicate handling for non-tower pieces
                if (entry._isDead) return;
                // Call handleDeath without broadcasting (already done by HOST)
                pieceDeployment.handleDeath(entry);
            }

            function setElixir(side, value, { emit = false } = {}) {
                if (typeof elixirManager === 'undefined') return;
                elixirManager.setElixir(side, value, { emit });
            }

            function getPieceEntryById(id, { warn = true } = {}) {
                if (!id || !pieceDeployment?.boardPieces) return null;
                const entry = pieceDeployment.boardPieces.find(p => p.id === id);
                if (!entry && warn) {
                    console.warn('[state_update] piece not found for id', id);
                }
                return entry;
            }

            function ensureHealthBarAttached(entry) {
                if (!entry) return;
                if (!entry.healthBar && typeof pieceDeployment?.attachHealthBar === 'function') {
                    pieceDeployment.attachHealthBar(entry);
                }
            }

            function syncPieceFromSnapshot(pieceMsg) {
                if (!pieceMsg || !pieceMsg.id) return;
                const row = parseInt(pieceMsg.row);
                const col = parseInt(pieceMsg.col);
                const type = pieceMsg.kind || pieceMsg.type;
                const allegiance = pieceMsg.owner || pieceMsg.allegiance || 'a';
                // king_tower: anchor 已经在棋盘上，不移动，只同步血量
                if (type === 'king_tower') {
                    if (typeof pieceMsg.hp === 'number') {
                        pieceDeployment.updateKingHealth(allegiance, pieceMsg.hp);
                    }
                    ensureKingTowers();
                    return;
                }
                const existing = pieceDeployment.boardPieces.find(p => p.id === pieceMsg.id);
                if (existing) {
                    if (Number.isInteger(row) && Number.isInteger(col)) {
                        pieceDeployment.movePiece(existing.id, { row, col }, { fromNetwork: true, skipBroadcast: true });
                        existing.position = { row, col };
                    }
                    if (typeof pieceMsg.hp === 'number') {
                        existing.hp = pieceMsg.hp;
                        ensureHealthBarAttached(existing);
                        if (existing.healthBar && typeof existing.healthBar.update === 'function') {
                            existing.healthBar.update(existing.hp);
                        }
                        pieceDeployment.refreshHealthTooltip?.(existing);
                    }
                    if (typeof pieceMsg.damage_reduction === 'number') {
                        existing.damageReduction = pieceMsg.damage_reduction;
                    }
                    const imagePath = pieceMsg.board_image_path || pieceMsg.boardImagePath;
                    if (imagePath) {
                        existing.boardImagePath = imagePath;
                        const img = existing.element ? existing.element.querySelector('img') : null;
                        if (img) {
                            img.src = imagePath;
                        }
                    }
                    return;
                }
                const cell = Number.isInteger(row) && Number.isInteger(col)
                    ? document.querySelector(`.board-cell[data-row="${row}"][data-col="${col}"]`)
                    : null;
                if (!cell) return;
                pieceDeployment.deployPiece(cell, null, {
                    fromNetwork: true,
                    skipElixir: true,
                    pieceType: type,
                    allegiance,
                    id: pieceMsg.id,
                    cost: pieceMsg.cost,
                    boardImagePath: pieceMsg.boardImagePath || pieceMsg.board_image_path
                });
                const entry = pieceDeployment.boardPieces.find(p => p.id === pieceMsg.id);
                if (entry) {
                    if (typeof pieceMsg.hp === 'number') entry.hp = pieceMsg.hp;
                    if (typeof pieceMsg.max_hp === 'number') entry.maxHP = pieceMsg.max_hp;
                    if (typeof pieceMsg.damage_reduction === 'number') entry.damageReduction = pieceMsg.damage_reduction;
                    ensureHealthBarAttached(entry);
                    if (entry.healthBar && typeof entry.healthBar.update === 'function' && typeof entry.hp === 'number') {
                        entry.healthBar.update(entry.hp);
                    }
                    const imagePath = pieceMsg.board_image_path || pieceMsg.boardImagePath;
                    if (imagePath) {
                        entry.boardImagePath = imagePath;
                        const img = entry.element ? entry.element.querySelector('img') : null;
                        if (img) {
                            img.src = imagePath;
                        }
                    }
                }
            }

            function broadcastElixirSnapshot() {
                if (!isHost || typeof elixirManager?.setElixir !== 'function') return;
                ['a', 'b'].forEach((side) => {
                    const value = elixirManager.getElixir ? elixirManager.getElixir(side) : 0;
                    elixirManager.setElixir(side, value, { emit: true });
                });
            }

            function processTowerSwitchRequest(allegiance) {
                if (!isHost) return;
                const side = allegiance === 'b' ? 'b' : 'a';
                if (typeof window.AggressiveTowerAbility?.canSwitchTowers === 'function') {
                    if (!window.AggressiveTowerAbility.canSwitchTowers(side)) {
                        postToParent('state_update', {
                            type: 'state_update',
                            event: 'error',
                            code: 'tower_switch_denied',
                            side
                        });
                        return;
                    }
                }
                if (!elixirManager?.spend?.(1, side)) {
                    postToParent('state_update', {
                        type: 'state_update',
                        event: 'error',
                        code: 'elixir_insufficient',
                        side,
                        action: 'tower_switch',
                        cost: 1
                    });
                    return;
                }
                const currentType = getTowerTypeForSide(side);
                const newType = currentType === 'solid' ? 'aggressive' : 'solid';
                const towers = (pieceDeployment.boardPieces || []).filter(p =>
                    p.allegiance === side &&
                    (p.type === 'aggressive_tower' || p.type === 'solid_tower')
                );
                window.AggressiveTowerAbility?.rescaleTowerStats?.(towers, newType);
                setTowerTypeForSide(side, newType);
                const serialized = towers.map(t => serializePiece(t));
                postToParent('state_update', {
                    type: 'state_update',
                    event: 'tower_switch',
                    side,
                    tower_type: newType,
                    towers: serialized
                });
                if (side === mySide) {
                    updateTowerToggle();
                }
            }

            function processSolidAbilityRequest(allegiance) {
                if (!isHost) return;
                const side = allegiance === 'b' ? 'b' : 'a';
                if (typeof window.SolidTowerAbility?.handleRequest === 'function') {
                    window.SolidTowerAbility.handleRequest(side, () => getTowerTypeForSide(side));
                }
            }

            function processAggressiveAbilityRequest(allegiance) {
                if (!isHost) return;
                const side = allegiance === 'b' ? 'b' : 'a';
                if (typeof window.AggressiveTowerAbility?.handleAbility2Request === 'function') {
                    window.AggressiveTowerAbility.handleAbility2Request(side, () => getTowerTypeForSide(side));
                }
            }

            function buildSnapshot() {
                const pieces = pieceDeployment.boardPieces.map(p => serializePiece(p));
                return {
                    type: 'state_update',
                    event: 'snapshot',
                    pieces,
                    elixir: {
                        a: elixirManager?.getElixir?.('a') ?? 0,
                        b: elixirManager?.getElixir?.('b') ?? 0
                    }
                };
            }

            function sendSnapshot() {
                if (!isHost) return;
                const payload = buildSnapshot();
                postToParent('state_update', payload);
            }

            function applySnapshot(msg) {
                if (msg.elixir) {
                    if (typeof msg.elixir.a === 'number') setElixir('a', msg.elixir.a);
                    if (typeof msg.elixir.b === 'number') setElixir('b', msg.elixir.b);
                }
                if (Array.isArray(msg.pieces)) {
                    msg.pieces.forEach(p => syncPieceFromSnapshot(p));
                }
                processPendingTowerEvents();
                processPendingDamageEvents();
                ensureKingTowers();
            }

            function updateTimerDisplay(seconds) {
                const display = document.getElementById('time-value');
                if (!display) return;
                const m = Math.floor(seconds / 60).toString().padStart(2, '0');
                const s = (seconds % 60).toString().padStart(2, '0');
                display.textContent = `${m}:${s}`;
            }

            function handleStateUpdate(msg) {
                const event = msg.event;
                const shouldLog = !isHost && ['damage', 'elixir', 'tower_switch', 'tower_ability_solid', 'tower_ability_aggressive'].includes(event);
                if (shouldLog) {
                    console.log('[client][state_update]', event, msg);
                }
                switch (event) {
                    case 'spawn':
                        spawnPieceFromServer(msg.piece);
                        break;
                    case 'damage':
                        applyDamageFromServer(msg.piece_id, msg.hp, msg.attacker_id);
                        break;
                    case 'death':
                        handleDeathFromServer(msg.piece_id);
                        break;
                    case 'elixir':
                        setElixir(msg.side, msg.elixir);
                        break;
                    case 'snapshot_request':
                        if (isHost) sendSnapshot();
                        break;
                    case 'snapshot':
                        applySnapshot(msg);
                        break;
                    case 'tower_switch_request':
                        processTowerSwitchRequest(msg.side || msg.allegiance);
                        break;
                    case 'tower_ability_solid_request':
                        processSolidAbilityRequest(msg.side || msg.allegiance);
                        break;
                    case 'tower_ability_aggressive_request':
                        processAggressiveAbilityRequest(msg.side || msg.allegiance);
                        break;
                    case 'timer':
                        updateTimerDisplay(msg.seconds_left);
                        break;
                    case 'tower_switch': {
                        console.log('[tower_switch] Received:', msg);
                        const newType = msg.tower_type;
                        const towers = msg.towers || [];
                        towers.forEach(t => {
                            const entry = getPieceEntryById(t.id);
                            if (!entry) {
                                console.warn('[tower_switch] Tower not found:', t.id);
                                return;
                            }

                            console.log('[tower_switch] Switching tower:', entry.id, 'from', entry.type, 'to', newType, 'hp:', t.hp, 'maxHP:', t.max_hp);

                            // 记录当前攻击状态
                            const wasAttacking = entry.attack;
                            const currentTarget = wasAttacking ? getPieceEntryById(entry.currentTargetId, { warn: false }) : null;
                            const oldType = entry.type;

                            // 停止旧的攻击动画
                            if (pieceDeployment?.stopTowerAttack) {
                                pieceDeployment.stopTowerAttack(entry);
                            }

                            // Remove old health bar before switching type
                            if (entry.healthBar && entry.healthBar.barWrapper) {
                                const oldBar = entry.healthBar.barWrapper;
                                if (oldBar.parentElement) {
                                    oldBar.parentElement.removeChild(oldBar);
                                }
                                entry.healthBar = null;
                                console.log('[tower_switch] Removed old healthBar');
                            }

                            // Update piece type and stats
                            const oldMaxHP = entry.maxHP;
                            entry.type = newType === 'solid' ? 'solid_tower' : 'aggressive_tower';
                            entry.maxHP = t.max_hp ?? entry.maxHP;
                            entry.hp = t.hp ?? entry.hp;
                            console.log('[tower_switch] Updated stats - maxHP:', oldMaxHP, '->', entry.maxHP, 'hp:', entry.hp);

                            const desiredPath = t.board_image_path || towerSpriteFor(newType, entry.allegiance || 'a');
                            entry.boardImagePath = desiredPath;

                            // Recreate health bar with new type's factory
                            let factory = null;
                            if (entry.type === 'aggressive_tower') factory = window.AggressiveTowerHP?.createHealthBar;
                            else if (entry.type === 'solid_tower') factory = window.SolidTowerHP?.createHealthBar;

                            if (factory && typeof factory === 'function' && entry.element) {
                                entry.healthBar = factory(entry.element);
                                console.log('[tower_switch] Created new healthBar:', entry.healthBar ? 'success' : 'failed');
                                if (entry.healthBar && typeof entry.healthBar.update === 'function') {
                                    entry.healthBar.update(entry.hp);
                                    console.log('[tower_switch] Updated healthBar to:', entry.hp);
                                }
                                // Reattach tooltip
                                if (pieceDeployment?.attachHealthTooltip) {
                                    pieceDeployment.attachHealthTooltip(entry);
                                }
                                if (pieceDeployment?.refreshHealthTooltip) {
                                    pieceDeployment.refreshHealthTooltip(entry);
                                }
                            } else {
                                console.warn('[tower_switch] Failed to create healthBar - factory:', !!factory, 'element:', !!entry.element);
                            }

                            // Update image
                            const img = entry.element ? entry.element.querySelector('img') : null;
                            if (img) {
                                img.src = desiredPath;
                            }

                            // 如果之前在攻击，用新类型重新启动攻击
                            if (wasAttacking && currentTarget) {
                                console.log('[tower_switch] Restarting attack with new type:', entry.type);
                                const visualOnly = window.IS_HOST !== true;
                                if (entry.type === 'aggressive_tower' && window.startAggressiveTowerAttack) {
                                    window.startAggressiveTowerAttack(entry, currentTarget, visualOnly);
                                } else if (entry.type === 'solid_tower' && window.startSolidTowerAttack) {
                                    window.startSolidTowerAttack(entry, currentTarget, visualOnly);
                                }
                            }
                        });
                        if (msg.side) {
                            setTowerTypeForSide(msg.side, newType);
                        }
                        if (typeof window.AggressiveTowerAbility?.init === 'function') {
                            updateTowerToggle();
                        }
                        break;
                    }
                    case 'tower_ability_solid': {
                        const targets = msg.targets || [];
                        targets.forEach(t => {
                            const entry = getPieceEntryById(t.id);
                            if (!entry) return;
                            ensureHealthBarAttached(entry);
                            const img = entry.element ? entry.element.querySelector('img') : null;
                            if (img) {
                                entry._originalImgSrc = entry._originalImgSrc || img.src;
                                img.src = '../pieces/solid_tower/solid_tower_ability.png';
                                setTimeout(() => {
                                    if (entry._originalImgSrc) img.src = entry._originalImgSrc;
                                }, msg.duration_ms || 3000);
                            }
                            entry.boardImagePath = '../pieces/solid_tower/solid_tower_ability.png';
                            entry.damageReduction = 0.75;
                        });
                        setTimeout(() => {
                            targets.forEach(t => {
                                const entry = getPieceEntryById(t.id, { warn: false });
                                if (!entry) return;
                                entry.damageReduction = 0;
                                const img = entry.element ? entry.element.querySelector('img') : null;
                                if (img && entry._originalImgSrc) {
                                    img.src = entry._originalImgSrc;
                                }
                                entry.boardImagePath = entry._originalImgSrc || entry.boardImagePath;
                            });
                        }, msg.duration_ms || 3000);
                        break;
                    }
                    case 'tower_ability_aggressive': {
                        const targets = msg.targets || [];
                        const duration = msg.duration_ms || 3000;
                        targets.forEach(t => {
                            const entry = getPieceEntryById(t.id);
                            if (!entry) return;
                            ensureHealthBarAttached(entry);
                            entry.damageReduction = typeof t.damage_reduction === 'number' ? t.damage_reduction : 0.25;
                            const img = entry.element ? entry.element.querySelector('img') : null;
                            const nextImg = t.board_image_path || '../pieces/agressive_tower/aggressive_tower_ability_2.png';
                            if (img) {
                                entry._aggOriginalImgSrc = entry._aggOriginalImgSrc || img.src;
                                img.src = nextImg;
                            }
                            entry.boardImagePath = nextImg;
                            if (Number.isInteger(t.row) && Number.isInteger(t.col)) {
                                pieceDeployment.movePiece(entry.id, { row: t.row, col: t.col }, { fromNetwork: true, skipBroadcast: true });
                                entry.position = { row: t.row, col: t.col };
                            }
                            if (Number.isInteger(t.original_row) && Number.isInteger(t.original_col)) {
                                entry._originalPosition = { row: t.original_row, col: t.original_col };
                            }
                        });
                        setTimeout(() => {
                            targets.forEach(t => {
                                const entry = getPieceEntryById(t.id, { warn: false });
                                if (!entry) return;
                                entry.damageReduction = 0;
                                const img = entry.element ? entry.element.querySelector('img') : null;
                                // Use allegiance-specific sprite as fallback
                                const defaultSprite = entry.allegiance === 'a'
                                    ? '../pieces/agressive_tower/aggressive_tower_a.png'
                                    : '../pieces/agressive_tower/aggressive_tower.png';
                                const fallback = t.original_image || entry._aggOriginalImgSrc || defaultSprite;
                                if (img) {
                                    img.src = fallback;
                                }
                                entry.boardImagePath = fallback;
                                if (entry._originalPosition) {
                                    pieceDeployment.movePiece(entry.id, { ...entry._originalPosition }, { fromNetwork: true, skipBroadcast: true });
                                    entry.position = { ...entry._originalPosition };
                                }
                            });
                        }, duration);
                        break;
                    }
                    case 'move': {
                        const targetId = msg.id || msg.piece_id;
                        if (!targetId) break;
                        const row = parseInt(msg.row);
                        const col = parseInt(msg.col);
                        pieceDeployment.movePiece(targetId, { row, col }, { fromNetwork: true, skipBroadcast: true });
                        const entry = getPieceEntryById(targetId, { warn: false });
                        if (entry) {
                            entry.position = { row, col };
                        }
                        break;
                    }
                    case 'ruler_move': {
                        const targetId = msg.id || msg.piece_id;
                        if (!targetId) break;
                        const row = parseInt(msg.row);
                        const col = parseInt(msg.col);
                        pieceDeployment.movePiece(targetId, { row, col }, { fromNetwork: true, skipBroadcast: true });
                        const entry = getPieceEntryById(targetId, { warn: false });
                        if (entry) {
                            entry.position = { row, col };
                        }
                        break;
                    }
                    case 'tower_attack': {
                        // Client receives attack event and plays visual effects only
                        console.log('[CLIENT] tower_attack received:', msg);
                        const attacker = getPieceEntryById(msg.attacker_id, { warn: false });
                        const target = getPieceEntryById(msg.target_id, { warn: false });
                        if (!attacker || !target) {
                            pendingTowerEvents.push({
                                type: 'start',
                                attacker_id: msg.attacker_id,
                                target_id: msg.target_id,
                                tower_type: msg.tower_type,
                                createdAt: Date.now()
                            });
                            console.warn('[CLIENT] tower_attack queued, missing attacker/target:', msg.attacker_id, msg.target_id);
                            break;
                        }
                        const towerType = msg.tower_type || attacker.type;
                        console.log('[CLIENT] Starting visual attack:', towerType, 'attacker:', attacker.id, 'target:', target.id);
                        startTowerVisualAttack(attacker, target, towerType);
                        break;
                    }
                    case 'tower_attack_stop': {
                        // Client receives stop attack event and clears animations
                        console.log('[CLIENT] tower_attack_stop received:', msg);
                        const attacker = getPieceEntryById(msg.attacker_id, { warn: false });
                        if (!attacker) {
                            pendingTowerEvents.push({
                                type: 'stop',
                                attacker_id: msg.attacker_id,
                                createdAt: Date.now()
                            });
                            console.warn('[CLIENT] tower_attack_stop queued, attacker missing:', msg.attacker_id);
                            break;
                        }
                        if (pieceDeployment?.stopTowerAttack) {
                            console.log('[CLIENT] Stopping attack for:', attacker.id);
                            pieceDeployment.stopTowerAttack(attacker);
                        }
                        break;
                    }
                    case 'game_over':
                        battleStarted = false;
                        alert(`Game over! Winner: ${msg.winner || '-'}`);
                        break;
                    case 'error':
                        if (!msg.side || msg.side === mySide) {
                            console.warn('[state_update error]', msg.code || msg.reason || 'unknown', msg);
                        }
                        break;
                    default:
                        break;
                }
            }

            function handleDeployRequest(msg) {
                if (!isHost) return;
                const row = parseInt(msg.row);
                const col = parseInt(msg.col);
                if (Number.isNaN(row) || Number.isNaN(col)) return;
                const allegiance = msg.allegiance || mySide || 'a';
                const pieceType = msg.pieceType || msg.cardType;
                const cost = msg.cost ?? (pieceDeployment?.getDefaultCost?.(pieceType) || 0);

                if (typeof elixirManager !== 'undefined') {
                    const spent = elixirManager.spend(cost, allegiance);
                    if (!spent) {
                        postToParent('state_update', {
                            type: 'state_update',
                            event: 'error',
                            code: 'elixir_insufficient',
                            side: allegiance,
                            action: 'deploy',
                            cost
                        });
                        return;
                    }
                }

                const cell = document.querySelector(`.board-cell[data-row="${row}"][data-col="${col}"]`);
                if (!cell) return;
                const pieceEntry = pieceDeployment.deployPiece(cell, null, {
                    pieceType,
                    allegiance,
                    cost,
                    boardImagePath: msg.boardImagePath,
                    skipBroadcast: true,  // Prevent deployPiece from calling handleLocalDeploy
                    fromNetwork: true
                });
                if (!pieceEntry || pieceEntry.requested) return;
                const payload = {
                    type: 'state_update',
                    event: 'spawn',
                    piece: serializePiece(pieceEntry),
                };
                postToParent('state_update', payload);
            }

            function handleRulerMoveRequest(msg) {
                if (!isHost) return;
                const targetId = msg.id || msg.piece_id;
                if (!targetId) return;
                const row = parseInt(msg.row);
                const col = parseInt(msg.col);
                if (Number.isNaN(row) || Number.isNaN(col)) return;
                const allegiance = msg.allegiance || mySide || 'a';

                const entry = pieceDeployment.boardPieces.find(p => p.id === targetId);
                if (!entry) return;
                if (msg.allegiance && entry.allegiance && msg.allegiance !== entry.allegiance) {
                    return;
                }

                const mover = entry._mover;
                if (mover && typeof mover.canMove === 'function' && !mover.canMove()) {
                    return;
                }
                const MOVE_COST = 1;
                const COOLDOWN_MS = 5000;
                if (typeof elixirManager !== 'undefined') {
                    const spent = elixirManager.spend(MOVE_COST, allegiance);
                    if (!spent) {
                        postToParent('state_update', {
                            type: 'state_update',
                            event: 'error',
                            code: 'elixir_insufficient',
                            side: allegiance,
                            action: 'ruler_move',
                            cost: MOVE_COST
                        });
                        return;
                    }
                }

                pieceDeployment.movePiece(targetId, { row, col }, { skipBroadcast: true });
                entry.position = { row, col };
                const now = Date.now();
                if (mover) {
                    mover.lastMoveAt = now;
                    mover.setCooldownVisual?.(true);
                    if (mover.cooldownTimer) clearTimeout(mover.cooldownTimer);
                    mover.cooldownTimer = setTimeout(() => mover.setCooldownVisual?.(false), COOLDOWN_MS);
                }

                postToParent('state_update', {
                    type: 'state_update',
                    event: 'ruler_move',
                    id: targetId,
                    row,
                    col,
                    allegiance: entry.allegiance
                });
            }

            function updateSideFlags(side) {
                const normalized = side === 'a' || side === 'b' ? side : 'spectate';
                mySide = normalized;
                isHost = normalized === 'a';
                window.GAME_SIDE = normalized;
                window.IS_HOST = isHost;
                window.isHost = isHost;
                window.MY_SIDE = normalized;
                IS_SPECTATOR = normalized === 'spectate';
                if (typeof elixirManager?.setSide === 'function') {
                    elixirManager.setSide(normalized);
                }
            }
            updateSideFlags(window.GAME_SIDE || window.PLAYER_SIDE || 'spectate');

            // Coordinate system: data-row and data-col are ABSOLUTE (like chess coordinates)
            // Row 0 = rank 8 (a8, b8, ..., h8), Row 7 = rank 1 (a1, b1, ..., h1)
            // Col 0 = file 'a', Col 7 = file 'h'
            // Regardless of board orientation, these coordinates stay the same.
            // Only the visual grid position changes based on orientation.

            function logicalToGridRow(row) {
                // For side A (viewing from bottom): row 0 should be at grid row 1, row 7 at grid row 8
                // For side B (viewing from top): row 0 should be at grid row 8, row 7 at grid row 1
                return boardOrientation === 'b' ? (8 - row) : (row + 1);
            }

            function logicalToGridCol(col) {
                // For side A: col 0 (file 'a') at grid col 1, col 7 (file 'h') at grid col 8
                // For side B: col 0 (file 'a') at grid col 8, col 7 (file 'h') at grid col 1
                return boardOrientation === 'b' ? (8 - col) : (col + 1);
            }

            function getDisplaySquare(row, col) {
                // Always display the absolute chess notation (e.g., "e4")
                // This does NOT change based on orientation
                return `${FILES[col]}${8 - row}`;
            }

            function createBoardGrid(orientation = boardOrientation) {
                const boardGrid = document.querySelector('.board-grid');
                if (!boardGrid) return;

                boardOrientation = orientation === 'b' ? 'b' : 'a';
                boardGrid.innerHTML = '';

                // Generate all cells with ABSOLUTE coordinates
                // data-row and data-col are always the same regardless of orientation
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'board-cell';

                        // ABSOLUTE coordinates (never change)
                        cell.dataset.row = row.toString();
                        cell.dataset.col = col.toString();

                        // Visual grid position (changes based on orientation)
                        cell.style.gridRow = logicalToGridRow(row).toString();
                        cell.style.gridColumn = logicalToGridCol(col).toString();

                        // Absolute chess notation (e.g., "a1", "e4", "h8")
                        const logicalSquare = `${FILES[col]}${8 - row}`;
                        cell.dataset.square = logicalSquare;

                        const label = document.createElement('span');
                        label.className = 'cell-label';
                        label.textContent = logicalSquare;
                        cell.appendChild(label);

                        boardGrid.appendChild(cell);
                    }
                }

                console.log(`[createBoardGrid] Created board with orientation: ${boardOrientation}`);
                console.log('[createBoardGrid] data-row and data-col are ABSOLUTE coordinates (same for both sides)');
            }

            function bindBoardCellDebugLogs() {
                const boardCells = document.querySelectorAll('.board-cell');
                boardCells.forEach(cell => {
                    cell.addEventListener('click', function() {
                        console.log(`[BoardCell] Clicked: square=${this.dataset.square}, row=${this.dataset.row}, col=${this.dataset.col}, gridRow=${this.style.gridRow}, gridCol=${this.style.gridColumn}`);
                    });
                });
            }

            function registerKingTowers(preservedShared = null) {
                if (typeof pieceDeployment === 'undefined') return;
                const boardGrid = document.querySelector('.board-grid');
                if (!boardGrid) return;

                const prevShared = preservedShared || {
                    a: pieceDeployment.kingTowerShared?.a ? { ...pieceDeployment.kingTowerShared.a } : null,
                    b: pieceDeployment.kingTowerShared?.b ? { ...pieceDeployment.kingTowerShared.b } : null
                };

                // 清理旧的 anchor 和缓存，避免重复挂载导致显示异常
                boardGrid.querySelectorAll('.king-anchor').forEach(el => el.remove());
                if (Array.isArray(pieceDeployment.boardPieces)) {
                    pieceDeployment.boardPieces = pieceDeployment.boardPieces.filter(p => p.type !== 'king_tower');
                }
                if (pieceDeployment.kingTowerShared) {
                    pieceDeployment.kingTowerShared = { a: null, b: null };
                }

                const swap = Math.random() >= 0.5;
                const kingImgA = swap ? '../pieces/king_tower/king_tower_2.png' : '../pieces/king_tower/king_tower_1.png';
                const kingImgB = swap ? '../pieces/king_tower/king_tower_1.png' : '../pieces/king_tower/king_tower_2.png';

                // createKingAnchor creates a 2x2 king tower anchor
                // For side A: should cover d1,d2,e1,e2 (rows 7,6 cols 3,4)
                // For side B: should cover d7,d8,e7,e8 (rows 1,0 cols 3,4)
                const createKingAnchor = (allegiance, imgSrc) => {
                    // Define absolute logical coordinates for the 2x2 area
                    const rows = allegiance === 'a' ? [6, 7] : [0, 1]; // A: ranks 2,1; B: ranks 8,7
                    const cols = [3, 4]; // files d,e

                    // Map logical coords to grid positions (depends on orientation)
                    const gridRows = rows.map(logicalToGridRow);
                    const gridCols = cols.map(logicalToGridCol);
                    const rowStart = Math.min(...gridRows);
                    const rowEnd = Math.max(...gridRows) + 1;
                    const colStart = Math.min(...gridCols);
                    const colEnd = Math.max(...gridCols) + 1;

                    // Create anchor div spanning 2x2 grid cells
                    const anchor = document.createElement('div');
                    anchor.className = 'king-anchor';
                    anchor.dataset.allegiance = allegiance;
                    anchor.style.gridRow = `${rowStart} / ${rowEnd}`;
                    anchor.style.gridColumn = `${colStart} / ${colEnd}`;
                    anchor.style.gridArea = `${rowStart} / ${colStart} / ${rowEnd} / ${colEnd}`;
                    anchor.innerHTML = `<img src="${imgSrc}" alt="King Tower">`;
                    boardGrid.appendChild(anchor);

                    // Register all 4 cells as king_tower pieces
                    rows.forEach((r) => {
                        cols.forEach((c) => {
                            pieceDeployment.registerStaticPiece('king_tower', r, c, allegiance, anchor);
                        });
                    });

                    // 恢复之前的血量（如果有）
                    const sharedCache = prevShared?.[allegiance];
                    if (sharedCache) {
                        pieceDeployment.updateKingHealth(allegiance, sharedCache.hp ?? sharedCache.maxHP ?? 1800);
                    }

                    // Basic sanity check：确保4个格子都存在
                    const missing = [];
                    rows.forEach((r) => {
                        cols.forEach((c) => {
                            const cell = document.querySelector(`.board-cell[data-row=\"${r}\"][data-col=\"${c}\"]`);
                            if (!cell) missing.push(`${r},${c}`);
                        });
                    });
                    const registeredCount = (pieceDeployment.boardPieces || []).filter(p => p.type === 'king_tower' && p.allegiance === allegiance).length;
                    console.log(`[registerKingTowers] Created ${allegiance} king tower at rows=${rows}, cols=${cols}, gridRow=${anchor.style.gridRow}, gridCol=${anchor.style.gridColumn}, missingCells=${missing.join('|') || 'none'}, registered=${registeredCount}`);
                };

                createKingAnchor('a', kingImgA);
                createKingAnchor('b', kingImgB);
            }

            function ensureKingTowers() {
                const boardGrid = document.querySelector('.board-grid');
                if (!boardGrid) return;
                const anchors = boardGrid.querySelectorAll('.king-anchor');
                const aCount = (pieceDeployment.boardPieces || []).filter(p => p.type === 'king_tower' && p.allegiance === 'a').length;
                const bCount = (pieceDeployment.boardPieces || []).filter(p => p.type === 'king_tower' && p.allegiance === 'b').length;
                if (anchors.length < 2 || aCount < 4 || bCount < 4) {
                    registerKingTowers();
                }
            }

            function startTimer() {
                if (timerInterval) return;
                remainingSeconds = 90;
                if (!isHost) return;
                const display = document.getElementById('time-value');
                const updateDisplay = () => {
                    const m = Math.floor(remainingSeconds / 60).toString().padStart(2, '0');
                    const s = (remainingSeconds % 60).toString().padStart(2, '0');
                    if (display) display.textContent = `${m}:${s}`;
                };
                updateDisplay();
                postToParent('state_update', {
                    type: 'state_update',
                    event: 'timer',
                    seconds_left: remainingSeconds
                });
                timerInterval = setInterval(() => {
                    if (remainingSeconds > 0) {
                        remainingSeconds--;
                        updateDisplay();
                        postToParent('state_update', {
                            type: 'state_update',
                            event: 'timer',
                            seconds_left: remainingSeconds
                        });
                    } else {
                        clearInterval(timerInterval);
                        timerInterval = null;
                    }
                }, 1000);
            }

            function towerSpriteFor(type, allegiance = 'a') {
                if (allegiance === 'a') {
                    if (type === 'solid' || type === 'solid_tower') return '../pieces/solid_tower/solid_tower_a.png';
                    if (type === 'aggressive' || type === 'aggressive_tower') return '../pieces/agressive_tower/aggressive_tower_a.png';
                }
                if (type === 'solid' || type === 'solid_tower') return '../pieces/solid_tower/solid_tower.png';
                if (type === 'aggressive' || type === 'aggressive_tower') return '../pieces/agressive_tower/aggressive_tower.png';
                return '';
            }

            function placeTowerOnBoard(row, col, towerType, allegiance = 'a') {
                const cell = document.querySelector(`.board-cell[data-row="${row}"][data-col="${col}"]`);
                if (!cell) {
                    console.error(`Cell not found at row ${row}, col ${col}`);
                    return null;
                }
                const allowedRow = allegiance === 'b' ? 1 : 6;
                if (row !== allowedRow || (col !== 1 && col !== 6)) {
                    console.warn('Blocked tower placement outside allowed slots.');
                    return null;
                }

                if (cell.querySelector('.tower-piece')) {
                    return cell.querySelector('.tower-piece');
                }

                const towerImagePath = towerSpriteFor(towerType, allegiance);
                if (!towerImagePath) {
                    console.error(`Unknown tower type: ${towerType}`);
                    return null;
                }

                const towerPiece = document.createElement('div');
                towerPiece.className = 'tower-piece';
                towerPiece.innerHTML = `<img src="${towerImagePath}" alt="${towerType} tower">`;
                towerPiece.dataset.towerType = towerType;

                cell.style.position = 'relative';
                cell.appendChild(towerPiece);

                if (typeof pieceDeployment !== 'undefined') {
                    const registryType = towerType === 'solid' ? 'solid_tower'
                        : towerType === 'aggressive' ? 'aggressive_tower'
                        : 'king_tower';
                    pieceDeployment.registerStaticPiece(registryType, row, col, allegiance, towerPiece, towerImagePath);
                }

                console.log(`Placed ${towerType} tower (${allegiance}) at row ${row}, col ${col}`);
                return towerPiece;
            }

            function initializeCards() {
                const cardSlots = document.querySelectorAll('.card-slot');
                CARD_CONFIG.forEach((card, idx) => {
                    const slot = cardSlots[idx];
                    if (!slot) return;
                    pieceDeployment.initializeCard(
                        slot,
                        card.type,
                        card.card,
                        card.board,
                        card.cost
                    );
                });
            }

            function initAbilities() {
                if (towerToggle && window.AggressiveTowerAbility) {
                    window.AggressiveTowerAbility.init({
                        toggleElement: towerToggle,
                        getCurrentPlayerTowers: () => currentPlayerTowers.filter(Boolean),
                        getPlayerTowerType: () => playerTowerType,
                        setPlayerTowerType: (type) => { playerTowerType = type; }
                    });
                }
                if (window.SolidTowerAbility) {
                    window.SolidTowerAbility.init({
                        getPlayerTowerType: () => playerTowerType
                    });
                }
            }

            function updateTowerToggle() {
                if (!towerToggle) return;
                const img1 = towerToggle.querySelector('.tower-img-1');
                const img2 = towerToggle.querySelector('.tower-img-2');
                const oppositeType = playerTowerType === 'solid' ? 'aggressive' : 'solid';

                // Update image sources based on player's allegiance
                const playerAllegiance = window.PLAYER_SIDE || 'a';
                const solidPath = towerSpriteFor('solid', playerAllegiance);
                const aggressivePath = towerSpriteFor('aggressive', playerAllegiance);

                if (img1) img1.src = solidPath;
                if (img2) img2.src = aggressivePath;

                if (oppositeType === 'solid') {
                    img1.style.display = 'block';
                    img2.style.display = 'none';
                } else {
                    img1.style.display = 'none';
                    img2.style.display = 'block';
                }
            }

            function beginMatch(startPayload = {}) {
                if (battleStarted) return;
                battleStarted = true;
                overlay.classList.add('hidden');

                const effectiveSide = (startPayload.side && startPayload.side !== 'spectate')
                    ? startPayload.side
                    : (window.PLAYER_SIDE || 'a');
                window.PLAYER_SIDE = effectiveSide;
                updateSideFlags(effectiveSide);
                pieceDeployment.setPlayerSide(IS_SPECTATOR ? 'spectate' : window.PLAYER_SIDE);
                OPPONENT_SIDE = window.PLAYER_SIDE === 'a' ? 'b' : 'a';

                const desiredOrientation = window.PLAYER_SIDE === 'b' ? 'b' : 'a';
                createBoardGrid(desiredOrientation);
                bindBoardCellDebugLogs();

                const towersFromServer = startPayload.towers || {};
                playerTowerType = selectedTower || towersFromServer[window.PLAYER_SIDE] || 'solid';
                opponentTowerType = towersFromServer[OPPONENT_SIDE] || opponentTowerType || 'aggressive';

                const playerRow = window.PLAYER_SIDE === 'a' ? 6 : 1;
                const oppRow = window.PLAYER_SIDE === 'a' ? 1 : 6;

                const tower1 = placeTowerOnBoard(playerRow, 1, playerTowerType, window.PLAYER_SIDE);
                const tower2 = placeTowerOnBoard(playerRow, 6, playerTowerType, window.PLAYER_SIDE);
                currentPlayerTowers = [tower1, tower2].filter(Boolean);

                placeTowerOnBoard(oppRow, 1, opponentTowerType, OPPONENT_SIDE);
                placeTowerOnBoard(oppRow, 6, opponentTowerType, OPPONENT_SIDE);

                updateTowerToggle();

                if (elixirManager && typeof elixirManager.reset === 'function') {
                    elixirManager.reset();
                }
                broadcastElixirSnapshot();
                elixirManager.startElixirGeneration();

                pieceDeployment.initialize();
                registerKingTowers();
                startTimer();
                initializeCards();
                initAbilities();
                if (isHost) {
                    sendSnapshot();
                } else {
                    postToParent('state_update', {
                        type: 'state_update',
                        event: 'snapshot_request',
                        side: window.PLAYER_SIDE
                    });
                }
            }

            function handleRemoteDeploy(msg) {
                const row = parseInt(msg.row);
                const col = parseInt(msg.col);
                if (Number.isNaN(row) || Number.isNaN(col)) return;

                const cell = document.querySelector(`.board-cell[data-row="${row}"][data-col="${col}"]`);
                if (!cell) return;

                const type = msg.pieceType || msg.piece_type;
                const allegiance = msg.allegiance || OPPONENT_SIDE || 'b';
                pieceDeployment.deployPiece(cell, null, {
                    fromNetwork: true,
                    allegiance,
                    id: msg.id,
                    pieceType: type,
                    cost: msg.cost ?? cardAssetMap[type]?.cost,
                    boardImagePath: msg.boardImagePath || cardAssetMap[type]?.board,
                });
            }

            function handleRemoteRulerMove(msg) {
                const targetId = msg.id;
                if (!targetId) return;
                const row = parseInt(msg.row);
                const col = parseInt(msg.col);
                pieceDeployment.movePiece(targetId, { row, col }, { fromNetwork: true, skipBroadcast: true });
                const entry = getPieceEntryById(targetId, { warn: false });
                if (entry) {
                    entry.position = { row, col };
                    if (entry._mover) {
                        entry._mover.lastMoveAt = Date.now();
                        entry._mover.setCooldownVisual?.(true);
                        setTimeout(() => entry._mover && entry._mover.setCooldownVisual?.(false), 5000);
                    }
                }
            }

            function selectTower(towerElement, towerType) {
                solidTowerOption.classList.remove('selected');
                aggressiveTowerOption.classList.remove('selected');

                towerElement.classList.add('selected');
                selectedTower = towerType;
                playerTowerType = towerType;
                console.log(`Tower selected: ${towerType}`);
            }

            function finalizeSelectionAndStart() {
                if (!selectedTower) return;
                // 默认把自己定为 A 侧以便本地单页也能开始；如果父级/WS 已经分配了 side 会被 startPayload 复用。
                const mySide = (window.PLAYER_SIDE && window.PLAYER_SIDE !== 'spectate') ? window.PLAYER_SIDE : 'a';
                const oppSide = mySide === 'a' ? 'b' : 'a';
                const payload = {
                    side: mySide,
                    towers: {
                        [mySide]: selectedTower,
                        [oppSide]: opponentTowerType || 'aggressive',
                    },
                };
                beginMatch(payload);
                if (!hasParentBridge) {
                    // 单页模式也通知后端 ready，避免卡住。
                    sendReadyDirect(selectedTower);
                }
            }

            function handleDoubleClick(towerElement, towerType) {
                clickCount++;

                if (clickCount === 1) {
                    selectTower(towerElement, towerType);
                    clickTimer = setTimeout(() => {
                        clickCount = 0;
                    }, 500);
                } else if (clickCount === 2) {
                    clearTimeout(clickTimer);
                    clickCount = 0;

                    if (selectedTower) {
                        console.log(`Tower confirmed: ${selectedTower}`);
                        finalizeSelectionAndStart();
                    }
                }
            }

            solidTowerOption.addEventListener('click', function() {
                handleDoubleClick(this, 'solid');
            });

            aggressiveTowerOption.addEventListener('click', function() {
                handleDoubleClick(this, 'aggressive');
            });

            createBoardGrid();
            bindBoardCellDebugLogs();

            const abilityButtons = document.querySelectorAll('.ability-button');
            abilityButtons.forEach(button => {
                button.addEventListener('click', function() {
                    console.log('Ability clicked:', this.textContent);
                });
            });
            if (window.RulerAbility && abilityButtons.length >= 2) {
                const rulerAbilityBtn = abilityButtons[abilityButtons.length - 2];
                window.RulerAbility.init({ button: rulerAbilityBtn });
            }

            window.addEventListener('message', (event) => {
                const msg = event.data || {};
                switch (msg.type) {
                    case 'side_update':
                        updateSideFlags(msg.payload?.side || msg.side);
                        break;
                    case 'state_update':
                        handleStateUpdate(msg.payload || msg);
                        break;
                    case 'battle_start':
                        beginMatch(msg.payload || {});
                        break;
                    case 'deploy_request':
                        handleDeployRequest(msg.payload || msg);
                        break;
                    case 'remote_deploy':
                        handleRemoteDeploy(msg.payload || msg);
                        break;
                    case 'remote_ruler_move':
                        handleRemoteRulerMove(msg.payload || msg);
                        break;
                    case 'ruler_move_request':
                        handleRulerMoveRequest(msg.payload || msg);
                        break;
                    case 'opponent_disconnected':
                        alert('Opponent disconnected.');
                        break;
                    default:
                        break;
                }
            });

            if (!hasParentBridge) {
                initStandaloneNetworking();
            }
        });

        window.handleLocalDeploy = function(payload) {
            console.log('[game_page] handleLocalDeploy called', payload, 'IS_HOST:', window.IS_HOST);
            const entry = pieceDeployment.boardPieces.find(p => p.id === payload.id);
            const serialized = serializePiece(entry || {
                id: payload.id,
                allegiance: payload.allegiance || window.PLAYER_SIDE,
                type: payload.pieceType,
                position: { row: payload.row, col: payload.col },
                hp: payload.hp,
                maxHP: payload.maxHP,
                boardImagePath: payload.boardImagePath
            });
            // handleLocalDeploy should ALWAYS send state_update (only HOST calls this)
            console.log('[game_page] sending state_update');
            postToParent('state_update', {
                type: 'state_update',
                event: 'spawn',
                piece: serialized
            });
        };

        window.handleLocalDeployRequest = function(payload) {
            console.log('[game_page] handleLocalDeployRequest called', payload);
            postToParent('deploy_request', {
                row: payload.row,
                col: payload.col,
                pieceType: payload.pieceType,
                allegiance: payload.allegiance || window.PLAYER_SIDE,
                cost: payload.cost,
                boardImagePath: payload.boardImagePath
            });
        };

        window.handleLocalRulerMove = function(payload) {
            console.log('[game_page] handleLocalRulerMove called', payload);
            const message = {
                id: payload.id,
                row: payload.row,
                col: payload.col,
                allegiance: payload.allegiance || window.PLAYER_SIDE,
            };
            if (window.IS_HOST === true) {
                postToParent('state_update', {
                    type: 'state_update',
                    event: 'ruler_move',
                    ...message
                });
            } else {
                postToParent('local_ruler_move', message);
            }
        };
    </script>

</body>
</html>
